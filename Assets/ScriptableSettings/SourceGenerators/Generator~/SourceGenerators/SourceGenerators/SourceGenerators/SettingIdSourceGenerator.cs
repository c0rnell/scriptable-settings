using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

[Generator]
public class SettingIdSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find partial structs that implement ISettingId<>
        var settingIdStructs = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsPartialStructWithInterface(s),
                transform: static (ctx, _) => GetSettingIdInfo(ctx))
            .Where(static info => info != null);

        context.RegisterSourceOutput(settingIdStructs, Execute);
    }

    private static bool IsPartialStructWithInterface(SyntaxNode node)
    {
        if (node is not StructDeclarationSyntax structDecl)
            return false;

        // Must be partial
        if (!structDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
            return false;

        // Must have a base list (implements interfaces)
        return structDecl.BaseList != null;
    }

    private static SettingIdInfo GetSettingIdInfo(GeneratorSyntaxContext context)
    {
        var structDecl = (StructDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        var typeSymbol = semanticModel.GetDeclaredSymbol(structDecl);
        if (typeSymbol == null) return null;

        // Find ISettingId<T> interface
        var settingIdInterface = typeSymbol.AllInterfaces
            .FirstOrDefault(i => i.IsGenericType && 
                               i.OriginalDefinition.Name == "ISettingId");

        if (settingIdInterface == null) return null;

        var settingType = settingIdInterface.TypeArguments[0];
        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();

        return new SettingIdInfo
        {
            StructName = typeSymbol.Name,
            NamespaceName = namespaceName,
            SettingTypeName = settingType.ToDisplayString(),
            SettingTypeSimpleName = settingType.Name
        };
    }

    private static void Execute(SourceProductionContext context, SettingIdInfo info)
    {
        var source = GenerateSettingIdImplementation(info);
        context.AddSource($"{info.StructName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateSettingIdImplementation(SettingIdInfo info)
    {
        var namespacePrefix = string.IsNullOrEmpty(info.NamespaceName) ? "" : $"namespace {info.NamespaceName}\n{{\n";
        var namespaceSuffix = string.IsNullOrEmpty(info.NamespaceName) ? "" : "}";
        var indent = string.IsNullOrEmpty(info.NamespaceName) ? "" : "    ";

        return $@"// <auto-generated />
using System;
using UnityEngine;
using Scriptable.Settings;
using Unity.Collections;

{namespacePrefix}{indent}[System.Serializable]
{indent}public partial struct {info.StructName} : System.IEquatable<{info.StructName}>, UnityEngine.ISerializationCallbackReceiver
{indent}{{
{indent}    public System.Guid Id {{ get; private set; }}
{indent}    
{indent}    [UnityEngine.SerializeField]
{indent}    private FixedString32Bytes i;

{indent}    public {info.StructName}(System.Guid id)
{indent}    {{
{indent}        Id = id;
{indent}        i = ShortGuid.Encode(id);
{indent}    }}

{indent}    public bool IsValid()
{indent}    {{
{indent}        return Id != System.Guid.Empty;
{indent}    }}

{indent}    bool System.IEquatable<{info.StructName}>.Equals({info.StructName} other)
{indent}    {{
{indent}        return i.Equals(other.i);
{indent}    }}
{indent}    
{indent}    public override bool Equals(object obj)
{indent}    {{
{indent}        return obj is {info.StructName} other && ((System.IEquatable<{info.StructName}>)this).Equals(other);
{indent}    }}
{indent}    
{indent}    public override int GetHashCode()
{indent}    {{
{indent}        return Id.GetHashCode();
{indent}    }}

{indent}    public {info.SettingTypeName} GetSetting()
{indent}    {{
{indent}        return ScriptableSettings.GetSetting<{info.StructName}, {info.SettingTypeName}>(this);
{indent}    }}
{indent}    
{indent}    public static {info.StructName} GetSettingId({info.SettingTypeName} setting)
{indent}    {{
{indent}        return new {info.StructName}(ScriptableSettings.GetSettingNode<{info.SettingTypeName}>(setting).Guid);
{indent}    }}
{indent}    
{indent}    void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
{indent}    {{
{indent}    }}

{indent}    void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
{indent}    {{
{indent}        Id = ShortGuid.Decode(i);
{indent}    }}
{indent}    
{indent}    public static bool operator ==({info.StructName} left, {info.StructName} right)
{indent}    {{
{indent}        return ((System.IEquatable<{info.StructName}>)left).Equals(right);
{indent}    }}

{indent}    public static bool operator !=({info.StructName} left, {info.StructName} right)
{indent}    {{
{indent}        return !((System.IEquatable<{info.StructName}>)left).Equals(right);
{indent}    }}
{indent}    
{indent}    public static implicit operator {info.StructName}({info.SettingTypeName} setting)
{indent}    {{
{indent}        return GetSettingId(setting);
{indent}    }}
{indent}    
{indent}    public static implicit operator {info.SettingTypeName}({info.StructName} settingId)
{indent}    {{
{indent}        return settingId.GetSetting();
{indent}    }}
{indent}}}
{namespaceSuffix}";
    }

    private class SettingIdInfo
    {
        public string StructName { get; set; }
        public string NamespaceName { get; set; }
        public string SettingTypeName { get; set; }
        public string SettingTypeSimpleName { get; set; }
    }
}